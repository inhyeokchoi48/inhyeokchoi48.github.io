<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>{4,6} hyperbolic tiling — Poincaré disk</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:system-ui,Segoe UI,Roboto}
    #ui{position:absolute;left:10px;top:10px;z-index:4;backdrop-filter: blur(4px);padding:8px;border-radius:8px;background:rgba(0,0,0,0.35)}
    canvas{display:block;margin:0 auto;background:#0b0b0b;}
    label{display:block;font-size:13px;margin:6px 0}
    input[type=range]{width:200px}
    button{margin-top:6px}
  </style>
</head>
<body>
  <div id="ui">
    <label>Levels: <span id="lev">5</span></label>
    <input id="levels" type="range" min="1" max="8" value="5">
    <label>Initial vertex radius (euclidean): <span id="rval">0.45</span></label>
    <input id="vr" type="range" min="0.05" max="0.7" step="0.01" value="0.45">
    <label>Stroke width: <span id="sw">1.2</span></label>
    <input id="swinput" type="range" min="0.5" max="3" step="0.1" value="1.2">
    <button id="regen">Regenerate</button>
    <div style="margin-top:6px;font-size:12px;opacity:0.9">Model: Poincaré disk. Tiles generated by reflecting a seed square across its edges (BFS).</div>
  </div>

  <canvas id="c"></canvas>

<script>
// Poincaré disk tiling {4,6} demonstration
// Strategy: place a regular 4-gon centered at origin with euclidean radius r0 (user control),
// compute geodesic circles for each edge (unique circle orthogonal to unit circle through the two vertices),
// then reflect the polygon across each edge (inversion in the geodesic circle) to produce neighbor polygons.
// Repeat BFS up to `levels` layers. This draws the tiling inductively from center.

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize(){
  canvas.width = Math.min(window.innerWidth, 1000);
  canvas.height = Math.min(window.innerHeight, 1000);
  draw();
}
window.addEventListener('resize', resize);

// helpers for complex numbers as arrays [x,y]
function c(x,y){return [x,y]}
function add(a,b){return [a[0]+b[0], a[1]+b[1]]}
function sub(a,b){return [a[0]-b[0], a[1]-b[1]]}
function mul(a,b){ // complex multiply
  return [a[0]*b[0]-a[1]*b[1], a[0]*b[1]+a[1]*b[0]]
}
function conj(a){return [a[0], -a[1]]}
function abs2(a){return a[0]*a[0]+a[1]*a[1]}
function abs(a){return Math.sqrt(abs2(a))}
function scale(a,s){return [a[0]*s, a[1]*s]}
function dot(a,b){return a[0]*b[0]+a[1]*b[1]}

// Solve for circle (center C, radius R) orthogonal to unit circle and passing through points z1,z2 inside unit disk.
// Unknowns: C = (u,v), R. Conditions:
// |z1 - C|^2 = R^2
// |z2 - C|^2 = R^2  -> subtract -> linear eqn for C
// Orthogonality to unit circle: |C|^2 - R^2 = 1
// Use the three equations to solve C and R.
function geodesicCircleThrough(z1,z2){
  // Represent as: 2*(z2 - z1) dot C = |z2|^2 - |z1|^2
  const A = sub(z2, z1);
  const B = 0.5*(abs2(z2) - abs2(z1));
  // A.x * u + A.y * v = B
  // Additionally, from |z1 - C|^2 = R^2 => R^2 = |z1|^2 - 2 z1·C + |C|^2
  // Orthogonality: |C|^2 - R^2 = 1 -> substitute R^2 -> |C|^2 - (|z1|^2 - 2 z1·C + |C|^2) = 1
  // simplifies to 2 z1·C - |z1|^2 = 1  => 2*(z1.x*u + z1.y*v) = 1 + |z1|^2
  const C1 = z1;
  const D = 0.5*(1 + abs2(z1)); // because 2 z1·C = 1 + |z1|^2 -> z1·C = D

  // So we have two linear equations in u,v:
  // A.x * u + A.y * v = B
  // C1.x * u + C1.y * v = D
  const det = A[0]*C1[1] - A[1]*C1[0];
  if (Math.abs(det) < 1e-9){
    // Points are nearly symmetric; fallback: place geodesic as straight line (diameter) through midpoint direction
    // Return a circle with huge radius approximating line
    const mid = scale(add(z1,z2),0.5);
    const dir = [-(z2[1]-z1[1]), z2[0]-z1[0]];
    // choose center far away along perpendicular direction so circle approximates line
    const C = add(mid, scale(dir, 1000));
    const R = Math.sqrt(Math.max(0, abs2(C) - 1));
    return {C,R};
  }
  const u = (B*C1[1] - A[1]*D)/det;
  const v = (A[0]*D - B*C1[0])/det;
  const Cc = [u,v];
  const R2 = abs2(sub(z1, Cc));
  return {C:Cc, R: Math.sqrt(R2)};
}

// Inversion of point z in circle (center C, radius R)
function invertInCircle(z, circle){
  const C = circle.C; const R = circle.R;
  const v = sub(z, C);
  const d2 = abs2(v);
  if (d2 === 0) return [Infinity, Infinity];
  const factor = (R*R)/d2;
  return add(C, scale(v, factor));
}

// Compute geodesic arc path between two points z1,z2 (as circle orthogonal to unit circle) to draw
function geodesicArcPath(z1,z2){
  const g = geodesicCircleThrough(z1,z2);
  const C = g.C, R = g.R;
  // For numerical issues when circle center far away, draw straight segment
  if (!isFinite(C[0]) || !isFinite(R) || Math.abs(C[0])>1e6){
    return {type:'line', a:z1, b:z2};
  }
  // Determine angles
  const a1 = Math.atan2(z1[1]-C[1], z1[0]-C[0]);
  const a2 = Math.atan2(z2[1]-C[1], z2[0]-C[0]);
  return {type:'arc', C, R, a1, a2};
}

function drawArc(ctx, arc){
  if (arc.type==='line'){
    ctx.moveTo( toCanvasX(arc.a[0]), toCanvasY(arc.a[1]) );
    ctx.lineTo( toCanvasX(arc.b[0]), toCanvasY(arc.b[1]) );
    return;
  }
  const C = arc.C; const R = arc.R;
  const cX = toCanvasX(C[0]); const cY = toCanvasY(C[1]);
  const s = scaleFactor();
  ctx.arc(cX, cY, R*s, arc.a1, arc.a2, false);
}

// convert from unit disk coords to canvas coords
function toCanvasX(x){ return canvas.width/2 + x*scaleFactor(); }
function toCanvasY(y){ return canvas.height/2 - y*scaleFactor(); }
function scaleFactor(){ return Math.min(canvas.width, canvas.height)/2 * 0.98; }

// Hash a polygon by its vertices (rounded) to avoid duplicates
function polyHash(verts){
  const arr = verts.map(z=> (z[0].toFixed(6)+','+z[1].toFixed(6))).sort().join('|');
  return arr;
}

// Build initial regular euclidean p-gon centered at origin with p=4
function seedPolygon(p, r){
  const verts = [];
  for(let k=0;k<p;k++){
    const theta = 2*Math.PI*k/p + Math.PI/p; // rotate so edges symmetric
    verts.push([r*Math.cos(theta), r*Math.sin(theta)]);
  }
  return verts;
}

// Reflect polygon across its edge i (edge between verts[i] and verts[(i+1)%p])
function reflectPolyAcrossEdge(poly, i){
  const p = poly.length;
  const z1 = poly[i];
  const z2 = poly[(i+1)%p];
  const circ = geodesicCircleThrough(z1,z2);
  const newVerts = poly.map(v => invertInCircle(v, circ));
  return newVerts;
}

// Main generator: BFS starting from seed poly
function generateTiling(p, levels, r0){
  const start = seedPolygon(p, r0);
  const queue = [{poly:start, level:0}];
  const seen = new Set();
  const polys = [];
  while(queue.length){
    const item = queue.shift();
    const poly = item.poly; const lvl = item.level;
    const h = polyHash(poly);
    if (seen.has(h)) continue;
    seen.add(h);
    polys.push({poly, level:lvl});
    if (lvl>=levels) continue;
    for(let i=0;i<p;i++){
      const neigh = reflectPolyAcrossEdge(poly,i);
      queue.push({poly:neigh, level:lvl+1});
    }
  }
  return polys;
}

// Drawing routine
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background circle for Poincaré disk
  ctx.save();
  ctx.translate(0,0);
  ctx.fillStyle = '#07070a';
  ctx.beginPath();
  ctx.arc(canvas.width/2, canvas.height/2, scaleFactor(), 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  const p = 4;
  const levels = parseInt(document.getElementById('levels').value);
  const r0 = parseFloat(document.getElementById('vr').value);
  const strokeW = parseFloat(document.getElementById('swinput').value);
  document.getElementById('lev').textContent = levels;
  document.getElementById('rval').textContent = r0;
  document.getElementById('sw').textContent = strokeW;

  const polys = generateTiling(p, levels, r0);

  // color palette across levels
  for(const item of polys){
    const poly = item.poly;
    const lvl = item.level;
    // fill slightly by level
    const hue = 200 - Math.min(180, lvl*12);
    ctx.beginPath();
    // draw polygon boundary via geodesic arcs
    const verts = poly;
    for(let i=0;i<verts.length;i++){
      const a = verts[i]; const b = verts[(i+1)%verts.length];
      const arc = geodesicArcPath(a,b);
      if(i===0){
        if(arc.type==='line') ctx.moveTo(toCanvasX(arc.a[0]), toCanvasY(arc.a[1]));
        else ctx.moveTo( toCanvasX(arc.C[0] + arc.R*Math.cos(arc.a1)), toCanvasY(arc.C[1] + arc.R*Math.sin(arc.a1)) );
      }
      if(arc.type==='line'){
        ctx.lineTo(toCanvasX(arc.b[0]), toCanvasY(arc.b[1]));
      } else {
        // draw arc sample as many small segments to avoid arc winding direction issues
        const steps = Math.max(6, Math.ceil(Math.abs(arc.a2 - arc.a1)/0.2));
        const da = (arc.a2 - arc.a1)/steps;
        for(let t=1;t<=steps;t++){
          const ang = arc.a1 + da*t;
          const px = arc.C[0] + arc.R*Math.cos(ang);
          const py = arc.C[1] + arc.R*Math.sin(ang);
          ctx.lineTo(toCanvasX(px), toCanvasY(py));
        }
      }
    }
    ctx.closePath();
    // fill with slight transparency
    ctx.fillStyle = `hsla(${hue},60%,30%,${Math.max(0.04, 0.14 - lvl*0.015)})`;
    ctx.fill();
    ctx.lineWidth = strokeW;
    ctx.strokeStyle = `hsla(210,20%,90%,${Math.max(0.18,0.6 - lvl*0.07)})`;
    ctx.stroke();
  }

  // outer circle border
  ctx.beginPath();ctx.lineWidth=2;ctx.strokeStyle='rgba(200,200,220,0.12)';ctx.arc(canvas.width/2, canvas.height/2, scaleFactor(), 0, Math.PI*2);ctx.stroke();
}

// UI hookup
document.getElementById('levels').addEventListener('input', draw);
document.getElementById('vr').addEventListener('input', draw);
document.getElementById('swinput').addEventListener('input', draw);
document.getElementById('regen').addEventListener('click', draw);

resize();

</script>
</body>
</html>
